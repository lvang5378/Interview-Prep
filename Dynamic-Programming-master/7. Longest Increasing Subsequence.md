##300. Longest Increasing Subsequence 
> Given an unsorted array of integers, find the length of longest increasing subsequence.

> For example,  
Given [10, 9, 2, 5, 3, 7, 101, 18],  
The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.

> Your algorithm should run in O(n2) complexity.  
Follow up: Could you improve it to O(n log n) time complexity?

---


###Method 1:
  For each number in the nums, find the longest increasing subsequence.

---
###Method 2: my method
  Binary Search and DP  
  - For current integer, all the numbers on its left should be in descending order. Find the position of current integer, and add one to the count for every number that's smaller than current number.
  
  - At the end, output the max count of any number in the vector.  

---
###Method 3:
Inspired by http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/
```c++
    int lengthOfLIS(vector<int>& nums) {
        vector<int> res;
        for(int i=0; i<nums.size(); i++) {
            auto it = std::lower_bound(res.begin(), res.end(), nums[i]);
            //lower_bound: Returns an iterator pointing to the first element in the range [first,last) 
            //which does not compare less than val.

            if(it==res.end()) res.push_back(nums[i]);
            else *it = nums[i];
        }
        return res.size();
    }
```
Time Complexity : O(N log N) 


#####Another Java solution:
```java
public class Solution {
    public int lengthOfLIS(int[] nums) {            
        int[] dp = new int[nums.length];
        int len = 0;

        for(int x : nums) {
            int i = Arrays.binarySearch(dp, 0, len, x);
            if(i < 0) i = -(i + 1);
            dp[i] = x;
            if(i == len) len++;
        }

        return len;
    }
}
```
The basic idea is present in the majority of solutions shared for this task, I have only tried to implement it in a manner as concise as possible without damaging the code readability.

The idea is that as you iterate the sequence, you keep track of the minimum value a subsequence of given length might end with, for all so far possible subsequence lengths. So dp[i] is the minimum value a subsequence of length i+1 might end with. Having this info, for each new number we iterate to, we can determine the longest subsequence where it can be appended using binary search. The final answer is the length of the longest subsequence we found so far.
